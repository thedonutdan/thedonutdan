<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>CRUD</title>

        <link rel="stylesheet" href="../assets/css/base.css">
        <link rel="stylesheet" href="../assets/css/post.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

        <link rel="stylesheet" href="../assets/css/prism.css">
        <script src="../assets/js/prism.js" defer></script>
    </head>

    <body>
        <header>
            <nav>
                <div class="container">
                    <a href="../index.html">Home</a>
                    <a href="blog.html" class="current">Blog</a>
                    <a href="../projects/projects.html">Projects</a>
                    <a href="../contact.html">Contact</a>
                </div>
            </nav>
        </header>

        <main class="container">
            <article class="blog-post">
                <aside class="contact-card">
                    <img src="../assets/images/profile.png" alt="Profile Image" width="128" height="128">
                    <strong>Daniel Andrews</strong>
                    San Diego, CA
                    <a href="mailto:andrewsdaniel999@hotmail.com">Email</a>
                    <a href="https://github.com/thedonutdan">Github</a>
                    <a href="https://linkedin.com/in/danielandrews-">LinkedIn</a>
                </aside>
                <section class="post-content">
                    <h1>CRUD</h1>
                    <p>Well, life has gotten crazy! In the month or so since my last post I finished my final quarter at UC San Diego and officially graduated yesterday!</p>
                    <p>n the meantime I have continued work on benchmarking, assessing, and optimizing my genetic routing algorithm that I implemented in my <a href="2025-06-26-genetic-algorithms.html">last post</a>.
                         However, I’ve been running my genetic algorithm with various inputs that are taking anywhere from 2 to 20+ hours to run– not entirely unexpected
                          but definitely a challenge when it comes to iterating quickly. I’ve been exploring performance improvements using thread pooling, but while
                           waiting for long runs to complete, I decided to start on a side project I’ve been wanting to build for a while: a vehicle maintenance tracking app.</p>
                    <p>
                        The idea is straightforward — a CRUD app that allows users to input vehicle data and update service records, giving individuals an easier way to track what’s 
                        been done and what’s coming up. While plenty of fleet management tools exist, this project is focused more on everyday drivers or households that need
                         something simpler and more personal than a spreadsheet. Something very useful to me considering I was never able to follow in my father’s footsteps and 
                         become an Excel wizard.
                    </p>
                    <p>
                        The timing also makes this project a perfect capstone for my CS degree. It’s a chance to apply everything I’ve learned — from backend architecture to
                         frontend design — in a full-stack web app that brings together multiple languages, frameworks, and real-world software engineering principles.
                    </p>
                    <h2>Backend Design</h2>
                    <hr>
                    <p>
                        Luckily for this project, I had already started building the app in Java with plans to utilize Java Swing to render a UI. But after getting the basic 
                        logic figured out, I realized that my logic was totally decoupled from any rendering so I wasn’t as of yet tied down to Swing. Plus, I’ve already done
                         enough work with Swing in my Asteroids project that I felt it was time to try something new. I played around with the idea of using a different Java
                          graphics library but ultimately settled on trying my hand at building a full stack webapp by converting what I had into a backend, setting up HTTP
                           endpoints, and handling rendering on a client side React App.
                    </p>
                    <h3>Data Model</h3>
                    <p>
                        Firstly, I copied over my existing models for vehicles, maintenance records, and service types. The idea here is to create models that are extensible.
                         To achieve this I set up a Vehicle class that holds general vehicle information (VIN, make, model, etc) and also a list of MaintenanceRecords which
                          allow us to add/remove records to update the maintenance history of the vehicle as well as extend maintenance records to contain any information we
                           might later want to add (or omit). On top of this, the ServiceType inside the maintenance record allows us to configure default service types such
                            as an oil change with a default expiration of 5,000 miles or 6 months etc. The idea being that our front end may later allow a user to just hit 
                            an “update” button on a specific type of service which will then automatically generate a new record, or even allow users to define specific 
                            defaults they want to follow like changing oil every 10,000 miles instead of 5,000.
                    </p>
                    <pre><code class="language-java">
package io.thedonutdan.vehiclemaintenance.model;


import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

import io.thedonutdan.vehiclemaintenance.DTO.VehicleDTO;

/** Represents a vehicle that is being monitored */
public class Vehicle {
    private UUID id;
    private UUID userId;
    private String VIN;
    private String make;
    private String model;
    private int year;
    private String licensePlate;
    private int mileage;
    private List<MaintenanceRecord> maintenanceHistory;

    /** For JSON serialization/deserialization */
    public Vehicle() {

    }

    public Vehicle(UUID userId, String VIN, String make, String model, int year, String licensePlate, int mileage) {
        this.id = UUID.randomUUID();
        this.userId = userId;
        this.VIN = VIN;
        this.make = make;
        this.model = model;
        this.year = year;
        this.licensePlate = licensePlate;
        this.mileage = mileage;
        this.maintenanceHistory = new ArrayList<>();
    }

    public Vehicle(UUID userId, String VIN, String make, String model, int year, String licensePlate, int mileage, List<MaintenanceRecord> maintenanceHistory) {
        this.id = UUID.randomUUID();
        this.userId = userId;
        this.VIN = VIN;
        this.make = make;
        this.model = model;
        this.year = year;
        this.licensePlate = licensePlate;
        this.mileage = mileage;
        this.maintenanceHistory = maintenanceHistory;
    }

    /**
     *  Adds a maintenance record to the vehicle, will update vehicle mileage if new 
     * @param record Maintenance record to be added to vehicle
    */
    public void addMaintenance(MaintenanceRecord record) {
        maintenanceHistory.add(record);
        if (record.getMileage() > mileage) {
            mileage = record.getMileage();
        }
    }


    /*(Getters, setters, equals, and hashcodes omitted for brevity)*/
}
                    </code></pre>
                    <p>
                        <code>Vehicle</code> is a pretty straightforward class. For the most part it just holds the vehicle data
                         with a little bit of logic to handle updating the maintenance history. Since it is mostly a 
                         modeling object for the backend to handle persistent storage the logic will be kept fairly 
                         simple. In later steps I added a <code>VehicleDTO</code> that omits backend-specific items such as the 
                         <code>userId</code> field since that is related to authentication/authorization and will be handled via 
                         a separate security configuration.
                    </p>
                    <pre><code class="language-java">
package io.thedonutdan.vehiclemaintenance.model;

import java.time.LocalDate;
import java.time.Period;
import java.util.Objects;

/**
 * Represents a record of a specific maintenance performed on a vehicle
 */
public class MaintenanceRecord {
    private LocalDate date;
    private ServiceType serviceType;
    private int mileage;
    private Integer expiryMileage;
    private LocalDate expiryDate;
    private String notes;

    /** For JSON serialization/deserialization */
    public MaintenanceRecord() {

    }
    /** Full Constructor
     * @param date The date the maintenance took place
     * @param serviceType The type of service performed
     * @param mileage The mileage of the vehicle at time of maintenance
     * @param expiryMiles The number of miles after the maintenance at which it should be repeated 
     * (e.g. 5000 means the maintenance is valid for 5000 miles). Can be null to indicate the record
     * should use the default values provided in ServiceType, which can also be null to indicate
     * no explicit expiry milage.
     * @param expiryTime The amount of time after the maintenance at which it should be repeated
     * (e.g. 6 months, 1 year, etc). Can be null to indicate the record should use the
     * default values provided in ServiceType, which can also be null to indicate no explicit
     * expiry time.
     * @param notes Any notes associate with the maintenance.
     */
    public MaintenanceRecord(LocalDate date, ServiceType serviceType, int mileage, Integer expiryMiles, Period expiryTime, String notes) {
        this.date = date;
        this.serviceType = serviceType;
        this.mileage = mileage;
        this.notes = notes;
        if (expiryMiles == null) {
            if (serviceType.getDefaultExpiryMiles() != null) {
                this.expiryMileage = mileage + serviceType.getDefaultExpiryMiles();
            }
        } else {
            this.expiryMileage = mileage + expiryMiles;
        }
        if (expiryTime == null) {
            if (serviceType.getDefaultExpiryTime() != null) {
                this.expiryDate = date.plus(serviceType.getDefaultExpiryTime());
            }
        } else {
            this.expiryDate = date.plus(expiryTime);
        }
    }

    public void computeAndSetExpiryMileage(Integer expiryMiles) {
        this.expiryMileage = mileage + expiryMiles;
    }
    
    public void computeAndSetExpiryDate(Period expiryTime) {
        this.expiryDate = this.date.plus(expiryTime);
    }

    /*(Getters, setters, equals, and hashcodes omitted for brevity)*/
}
                    </code></pre>
                    <p>
                        MaintenanceRecord is another pretty simple class, however it has a unique element in that if <code>expiryMileage</code>
                         or <code>expiryDate</code> are left null in the constructor, they will try to inherit from the ServiceType defaults.
                          If those are null, then the service is treated as if it has no expiration (think an alternator replacement, there is 
                          no specific maintenance interval for that kind of work).
                    </p>
                    <pre><code class="language-java">
package io.thedonutdan.vehiclemaintenance.model;

import java.time.Period;
import java.util.Objects;

/**
 * Represents a Service Type with optional default expiry miles and time
 */
public class ServiceType {
    private String name;
    private Integer defaultExpiryMiles;
    private Period defaultExpiryTime;

    /** Default constructor for JSON serialization/deserialization */
    public ServiceType() {

    }

    /** Full Constructor
     * 
     * @param name Name of service type (i.e. 'Oil Change', 'Tire Rotation', etc.)
     * @param defaultExpiryMiles The default amount of miles after which this service should be repeated.
     *  Can be left null to indicate no explicit expiry miles.
     * @param defaultExpiryTime The default amount of time after which this service should be repeated.
     *  Can be left null to indicate no explicit expiry time.
     */
    public ServiceType(String name, Integer defaultExpiryMiles, Period defaultExpiryTime) {
        this.name = name;
        this.defaultExpiryMiles = defaultExpiryMiles;
        this.defaultExpiryTime = defaultExpiryTime;
    }

    /*(Getters, setters, equals, and hashcodes omitted for brevity)*/
}
                    </code></pre>
                    <p>
                        <code>ServiceType</code> is really a purely data-focused class. It simply exists to allow configuration of service types based on user preferences,
                         which will be handled on the front end.
                    </p>
                    <h3>Data Management</h3>
                    <p>
                        We are now moving into the logical side of our backend, where we will handle the actual CRUD operations that will be performed on our vehicles.
                         Originally I had a <code>VehicleManager</code> class that handled all the CRUD operations and stored data locally in a JSON. This is perfectly acceptable 
                         for a small local app but to align better with common backend design principles I decided to abstract out data storage and make <code>VehicleManager</code> 
                         a stateless component. To do this I defined a <code>VehicleDAO</code> interface as well as a <code>SQLiteVehicleDAO</code> implementation to go along with it. This way
                          <code>VehicleManager</code> can simply call interface methods on whatever DAO (Data Access Object) implementation is provided, handle authorization (remember
                           the userId field from `<code>Vehicle</code>?) and handle transferring data across layers between the actual endpoint controller and the database.
                    </p>
                    <pre><code class="language-java">
package io.thedonutdan.vehiclemaintenance.DAO;

import io.thedonutdan.vehiclemaintenance.model.Vehicle;

import java.util.List;
import java.util.UUID;

/**
 * Vehicle data access interface for interacting with vehicles in database
 */
public interface VehicleDAO {    
    /** Adds a vehicle to the database
     * @param vehicle Vehicle to be added to the database
     * @return True if insertion is successful, false on failure
     */
    public boolean insert(Vehicle vehicle);
    /**
     * Retrieves a vehicle by its id
     * @param id id of vehicle to retrieve
     * @return vehicle corresponding to id or null if not found
     */
    public Vehicle findById(UUID id);
    /**
     * Retrieves all vehicles related to a specific user id
     * @param id User id to find associated vehicles
     * @return List of vehicles associated with given user id
     */
    public List<Vehicle> findByUserId(UUID id);
    /**
     * Updates a vehicle in the database
     * @param vehicle Updated vehicle
     * @return True on successful update, false on failure
     */
    public boolean update(Vehicle vehicle);
    /**
     * Removes a vehicle from the database
     * @param id Id of vehicle to remove
     * @return True on successful removal, false on failure
     */
    public boolean delete(UUID id);
}
                    </code></pre>
                    <p>And one possible implementation:</p>
                    <pre><code class="language-java">
package io.thedonutdan.vehiclemaintenance.DAO.impl;

import io.thedonutdan.vehiclemaintenance.DAO.VehicleDAO;
import io.thedonutdan.vehiclemaintenance.model.MaintenanceRecord;
import io.thedonutdan.vehiclemaintenance.model.ServiceType;
import io.thedonutdan.vehiclemaintenance.model.Vehicle;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.time.Period;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * Vehicle Data Access Object for SQLite configuration
 */
public class SQLiteVehicleDAO implements VehicleDAO {
    private final Connection conn;

    public SQLiteVehicleDAO(Connection conn) {
        this.conn = conn;
    }

    @Override
    public boolean insert(Vehicle vehicle) {
        String vehiclesQuery = """
            INSERT INTO vehicles (
                id,
                user_id,
                vin,
                make,
                model,
                year,
                license_plate,
                mileage
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """;
        
        String maintenanceRecordsQuery = """
                INSERT INTO maintenance_records (
                vehicle_id,
                date,
                service_type_name,
                service_type_default_expiry_miles,
                service_type_default_expiry_time,
                mileage,
                expiry_mileage,
                expiry_date,
                notes
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """;
        
        try {
            conn.setAutoCommit(false);
    
            try (PreparedStatement stmt = conn.prepareStatement(vehiclesQuery)) {
                stmt.setString(1, vehicle.getId().toString());
                stmt.setString(2, vehicle.getUserId().toString());
                stmt.setString(3, vehicle.getVIN());
                stmt.setString(4, vehicle.getMake());
                stmt.setString(5, vehicle.getModel());
                stmt.setInt(6, vehicle.getYear());
                stmt.setString(7, vehicle.getLicensePlate());
                stmt.setInt(8, vehicle.getMileage());
                
                executeStrictUpdate(stmt, 1);
            }
    
            for (MaintenanceRecord record : vehicle.getMaintenanceHistory()) {
                try (PreparedStatement stmt = conn.prepareStatement(maintenanceRecordsQuery)) {
                    ServiceType st = record.getServiceType();
                    stmt.setString(1, vehicle.getId().toString());
                    stmt.setString(2, record.getDate().toString());
                    stmt.setString(3, st.getName());
                    if (st.getDefaultExpiryMiles() != null) {
                        stmt.setInt(4, st.getDefaultExpiryMiles());
                    } else {
                        stmt.setNull(4, java.sql.Types.INTEGER);
                    }
                    stmt.setString(5, st.getDefaultExpiryTime() != null ? st.getDefaultExpiryTime().toString() : null);
                    stmt.setInt(6, record.getMileage());
                    if (record.getExpiryMileage() != null) {
                        stmt.setInt(7, record.getExpiryMileage());
                    } else {
                        stmt.setNull(7, java.sql.Types.INTEGER);
                    }
                    stmt.setString(8, record.getExpiryDate() != null ? record.getExpiryDate().toString() : null);
                    stmt.setString(9, record.getNotes());
                    
                    executeStrictUpdate(stmt, 1);
                }
            }
    
            conn.commit();
            return true;
    
        } catch (SQLException e) {
            try {
                conn.rollback();
            } catch (SQLException rollbackEx) {
                rollbackEx.printStackTrace();
            }
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public List<Vehicle> findByUserId(UUID userId) {
        String vehiclesQuery = """
                SELECT * FROM vehicles WHERE user_id = ?
                """;
        List<Vehicle> vehicles = new ArrayList<>();

        try (PreparedStatement stmt = conn.prepareStatement(vehiclesQuery)) {
            stmt.setString(1, userId.toString());

            ResultSet rs = stmt.executeQuery();

            while(rs.next()) {
                Vehicle vehicle = new Vehicle();
                vehicle.setId(UUID.fromString(rs.getString("id")));
                vehicle.setUserId(UUID.fromString(rs.getString("user_id")));
                vehicle.setVIN(rs.getString("vin"));
                vehicle.setMake(rs.getString("make"));
                vehicle.setModel(rs.getString("model"));
                vehicle.setYear(rs.getInt("year"));
                vehicle.setLicensePlate(rs.getString("license_plate"));
                vehicle.setMileage(rs.getInt("mileage"));
                vehicle.setMaintenanceHistory(getMaintenanceRecords(vehicle.getId()));

                vehicles.add(vehicle);
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }

        return vehicles;
    }

    private void executeStrictUpdate(PreparedStatement stmt, int expectedRows) throws SQLException {
        int affected = stmt.executeUpdate();
        if (affected != expectedRows) {
            throw new SQLException(String.format("Expected %d rows affected, got %d", expectedRows, affected));
        }
    }

    /*(Some methods omitted for brevity)*/
}
                    </code></pre>
                    <p>
                        CSE 132A Database System Principles finally paid off! Now the queries here are pretty simple, 
                        but I did make sure to concern myself with atomic updates to avoid problems like partial vehicle 
                        creation/deletion, especially when storing vehicles and associated maintenance records in different 
                        tables could lead to orphaned records that would be difficult to catch. Originally I had actually
                         implemented authorization through filtering in my SQL DAO with queries like
                    </p>
                    <pre><code class="language-sql">
SELECT * FROM vehicles WHERE id = ? AND user_id = ?
                    </code></pre>
                    <p>
                        but later decided that was a bad idea for a few reasons. Number one, it conflicts with my focus on
                         separation of concerns. A DAO should be a DAO. It exists as a way to abstract storage methods, not 
                         a way to secretly authorize access. Number two, putting authorization in the implementation without
                          strictly enforcing it in the interface leads to cases where one DAO provides authorization and 
                          another does not. This is a dangerous situation to be in. So with that in mind, I decided to go 
                          ahead and update my VehicleManager to enforce authorization before returning data fetched from the DAO.
                    </p>
                    <pre><code class="language-java">
package io.thedonutdan.vehiclemaintenance.manager;

import io.thedonutdan.vehiclemaintenance.DAO.VehicleDAO;
import io.thedonutdan.vehiclemaintenance.model.MaintenanceRecord;
import io.thedonutdan.vehiclemaintenance.model.Vehicle;

import java.util.List;
import java.util.UUID;

/**
 * Manages validated requests from control and provides authorization for database access. Creates, reads, updates, and deletes vehicles.
 */
public class VehicleManager {
    private final VehicleDAO vehicleDAO;

    public VehicleManager(VehicleDAO vehicleDAO) {
        this.vehicleDAO = vehicleDAO;
    }

    /**
     * Adds a vehicle to the database
     * @param vehicle Vehicle to be added to database
     */
    public void addVehicle(Vehicle vehicle) {
        vehicleDAO.insert(vehicle);
    }

    /**
     * Retrieves a vehicle from the database
     * @param vehicleId id of vehicle to be retrieved
     * @param userId id of associated user, must be validated
     * @return Vehicle object if it exists and user is authorized, null otherwise
     */
    public Vehicle getVehicleById(UUID vehicleId, UUID userId) {
        Vehicle v = vehicleDAO.findById(vehicleId);
        if (!v.getUserId().equals(userId)) {
            return null;
        }
        return v;
    }

    /**
     * Retrieves all vehicle associated with given user id
     * @param userId User id to retrieve vehicles for
     * @return List of vehicles associated with given user id
     */
    public List<Vehicle> getVehiclesByUserId(UUID userId) {
        return vehicleDAO.findByUserId(userId);
    }

    /**
     * Updates a vehicle in the database
     * @param userId User id associated with vehicle
     * @param vehicle Updated vehicle object
     * @return True if update is successful, null if update is unsuccessful or user is not authorized
     */
    public boolean updateVehicle(UUID userId, Vehicle vehicle) {
        Vehicle existing = vehicleDAO.findById(vehicle.getId());
        if (existing == null || !existing.getUserId().equals(userId)) {
            return false;
        }
        vehicle.setUserId(userId);
        return vehicleDAO.update(vehicle);
    }

    /**
     * Removes a vehicle from the database
     * @param userId Associated user id used for authorization
     * @param vehicleId Id of vehicle to be removed
     * @return True on successful removal, false on failure or if user is not authorized
     */
    public boolean deleteVehicle(UUID userId, UUID vehicleId) {
        Vehicle existing = vehicleDAO.findById(vehicleId);
        if (existing == null || !existing.getUserId().equals(userId)) {
            return false;
        }

        return vehicleDAO.delete(vehicleId);
    }

    /**
     * Adds a maintenance record to a vehicle in the database
     * @param userId Associated user id for authorization
     * @param vehicleId Id of vehicle to add maintenance record to
     * @param record Record object to be added to vehicle
     * @return True upon successful update, false on failure or if user is not authorized
     */
    public boolean addMaintenanceRecord(UUID userId, UUID vehicleId, MaintenanceRecord record) {
        Vehicle vehicle = vehicleDAO.findById(vehicleId);
        if (vehicle == null || !vehicle.getUserId().equals(userId)) {
            return false;
        }

        vehicle.addMaintenance(record);
        return vehicleDAO.update(vehicle);
    }
}
                    </code></pre>
                    <p>
                        And we have properly separated authorization from data access. Now in this iteration, and currently,
                         it could be noticed that there is no authorization checks on vehicle creation. Why is this? Well 
                         because in the layer above I actually convert a <code>VehicleDTO</code> (which doesn’t carry the userId field) 
                         to a <code>Vehicle</code>. The controller injects the associated userId automatically into the vehicle passed 
                         to the manager so it’s really not much of a concern. However, upon rethinking this code as I 
                         upload it into the blogpost I realize this is probably not great practice. Even though our 
                         current implementation guarentees authorization, future refactors could silently break this
                          guarantee. This goes against the concept of TDD (Test-Driven Development) which I’ve been 
                          adhering to so far. So I plan on my next commit introducing some logic like:
                    </p>
                    <pre><code class="language-java">
    /**
     * Adds a vehicle to the database
     * @param vehicle Vehicle to be added to database
     * @param userId Associated user Id for authorization
     */
    public boolean addVehicle(Vehicle vehicle, UUID userId) {
        if (!userId.equals(vehicle.getUserId())) {
          return false;
        } else {
          return vehicleDAO.insert(vehicle);
        }
    }
                    </code></pre>
                    <p>
                        This will properly handle the case where some future implementation of other components 
                        could theoretically try to create a vehicle with a user id stored in the vehicle that 
                        does not match the authenticated id. This helps to separate concerns and avoid unwritten 
                        guarantees that could cause regressions in later updates.
                    </p>
                    <h3>Conclusion</h3>
                    <hr>
                    <p>
                        That takes care of modeling, persistence storage, and stateless management. Note the lack of data validation in 
                        <code>VehicleManager</code>. This is a deliberate design choice. I decided to put data validation in the controller 
                        which will provide endpoints. This is a branching point where I think either packaging validation and authorization
                         into the controller that exposes the endpoints would be reasonable enough and slightly reduce complexity, but I 
                         felt that it followed my mantra with this project to separate these two aspects into different responsibilities. 
                         What are the benefits of doing it this way? Separation of concerns, testability, and easier identification of 
                         failure points. The cons? More complex code/file structure, and VehicleManager will now always assume it is being 
                         passed validated data. So changes on layers above it will have to keep that in mind.
                    </p>
                    <h3>Testing</h3>
                    <hr>
                    <p>
                        I mentioned utilizing TDD earlier but have not provided any tests in this post. Considering the lengthiness of some
                         of the codeblocks I omitted the actual tests but they can easily be viewed 
                         <a href="https://github.com/thedonutdan/VehicleMaintenanceReactApp/tree/main/backend/src/test/java/io/thedonutdan/vehiclemaintenance">here</a>.
                          Due to the fairly simple nature of
                          our data model/management the tests are quite straightforward. After implementing the server, api, and security
                           side of things I will have to work on also implementing some integration testing to go along with the existing unit tests.
                    </p>
                    <h3>Next Steps</h3>
                    <hr>
                    <p>
                        The next steps for this project will be setting up a server, exposing API endpoints, and getting a small frontend going to ensure it is working.
                         Further on we’ll actually implement authentication properly and then move on to rigging up a complete frontend.
                    </p>
                    <p>Sourcecode: <a href="https://github.com/thedonutdan/VehicleMaintenanceReactApp">github.com/thedonutdan/VehicleMaintenanceReactApp</a></p>
                </section>
            </article>
        </main>
        <footer>
            Daniel Andrews
        </footer>
    </body>
</html>