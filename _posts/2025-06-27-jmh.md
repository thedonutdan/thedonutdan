---
title: "Benchmarking with JMH"
date: 2025-06-27
header:
  og_image: /assets/images/genetic-algo.jpg
  teaser: /assets/images/genetic-algo.jpg
---

In my last post I detailed how I built a Genetic Routing Algorithm to solve TSP. Up to this point I have only used JUnit with Maven to verify correctness, that is, the route returned visits each node exactly once and forms exactly one cycle, starting and ending at the distribution center. Today we will be adding Java Microbenchmark Harness to our project in order to provide a way to benchmark the performance of each router. My plan today is to set up the scaffolding which will allow new routers to easily be integrated into the benchmarking framework. I also plan to implement an optimality tester which will give us data on how our routers are performing.

To get JMH set up in our project I added the following dependencies to `pom.xml`:
```xml
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-core</artifactId>
    <version>1.37</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-generator-annprocess</artifactId>
    <version>1.37</version>
    <scope>test</scope>
</dependency>
```
The scope has been set as test, since Maven naturally expects `/main` and `/test` directories in the project, so for now we will just include our benchmarks under the test directory as it integrates smoothly. We will also need some plugins:
```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.13.0</version>
    <configuration>
        <source>17</source>
        <target>17</target>
        <annotationProcessorPaths>
            <path>
                <groupId>org.openjdk.jmh</groupId>
                <artifactId>jmh-generator-annprocess</artifactId>
                <version>1.37</version>
            </path>
        </annotationProcessorPaths>
    </configuration>
</plugin>
<plugin>
    <artifactId>maven-dependency-plugin</artifactId>
    <executions>
        <execution>
            <id>build-classpath</id>
            <goals>
                <goal>build-classpath</goal>
            </goals>
            <configuration>
                <includeScope>runtime</includeScope>
                <outputProperty>depClasspath</outputProperty>
            </configuration>
        </execution>
    </executions>
</plugin>
<plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>exec-maven-plugin</artifactId>
    <version>3.1.0</version>
    <executions>
        <execution>
            <goals>
                <goal>java</goal>
            </goals>
        </execution>
    </executions>
    <configuration>
        <mainClass>io.seedshare.tsp.api.impl.BenchmarkRunner</mainClass>
        <classpathScope>test</classpathScope>
    </configuration>
</plugin>
```
Now it's time to go ahead and make a basic benchmark and benchmark runner to ensure our scaffolding works the way we are expecting:
```java
package io.seedshare.tsp.api.impl;

import org.openjdk.jmh.annotations.Benchmark;

public class BenchmarkTest {
  @Benchmark
  public void init() {
    // Do nothing
  }
}
```
We've just put together a real simple donothing test which will make sure we can run the benchmarks, and also give us an idea of what kind of overhead will go into our benchmarks. To run our benchmarks we have:
```java
package io.seedshare.tsp.api.impl;

public class BenchmarkRunner {
  public static void main(String[] args) throws Exception {
    org.openjdk.jmh.Main.main(args);
  }
}
```
With our setup, JMH will automatically look for functions with the `@benchmark` annotation and run them together.