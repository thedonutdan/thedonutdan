---
title: "CRUD App"
date: 2025-08-03
header:
  og_image: /assets/images/genetic-algo.jpg
  teaser: /assets/images/genetic-algo.jpg
---

Well, life has gotten crazy! In the month or so since my last post I finished my final quarter at UC San Diego and officially graduated yesterday! 

In the meantime I have continued work on benchmarking, assessing, and optimizing my genetic routing algorithm that I implemented in [my last post](./2025-06-26-genetic-algorithms.md). However, I've been running my genetic algorithm with various inputs that are taking anywhere from 2 to 20+ hours to run-- not entirely unexpected but definitely a challenge when it comes to iterating quickly. I've been exploring performance improvements using thread pooling, but while waiting for long runs to complete, I decided to start on a side project I've been wanting to build for a while: a vehicle maintenance tracking app.

The idea is straightforward — a CRUD app that allows users to input vehicle data and update service records, giving individuals an easier way to track what’s been done and what’s coming up. While plenty of fleet management tools exist, this project is focused more on everyday drivers or households that need something simpler and more personal than a spreadsheet. Something very useful to me considering I was never able to follow in my father's footsteps and become an Excel wizard.

The timing also makes this project a perfect capstone for my CS degree. It’s a chance to apply everything I’ve learned — from backend architecture to frontend design — in a full-stack web app that brings together multiple languages, frameworks, and real-world software engineering principles.

## Backend Design

Luckily for this project, I had already started building the app in Java with plans to utilize Java Swing to render a UI. But after getting the basic logic figured out, I realized that my logic was totally decoupled from any rendering so I wasn't as of yet tied down to Swing. Plus, I've already done enough work with Swing in my [Asteroids project](../_projects/asteroids.md) that I felt it was time to try something new. I played around with the idea of using a different Java graphics library but ultimately settled on trying my hand at building a full stack webapp by converting what I had into a backend, setting up HTTP endpoints, and handling rendering on a client side React App.

### Data Model

Firstly, I copied over my existing models for vehicles, maintenance records, and service types. The idea here is to create models that are extensible. To achieve this I set up a `Vehicle` class that holds general vehicle information (VIN, make, model, etc) and also a list of `MaintenanceRecords` which allow us to add/remove records to update the maintenance history of the vehicle as well as extend maintenance records to contain any information we might later want to add (or omit). On top of this, the `ServiceType` inside the maintenance record allows us to configure default service types such as an oil change with a default expiration of 5,000 miles or 6 months etc. The idea being that our front end may later allow a user to just hit an "update" button on a specific type of service which will then automatically generate a new record, or even allow users to define specific defaults they want to follow like changing oil every 10,000 miles instead of 5,000.

``` java
package io.thedonutdan.vehiclemaintenance.model;


import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

import io.thedonutdan.vehiclemaintenance.DTO.VehicleDTO;

/** Represents a vehicle that is being monitored */
public class Vehicle {
    private UUID id;
    private UUID userId;
    private String VIN;
    private String make;
    private String model;
    private int year;
    private String licensePlate;
    private int mileage;
    private List<MaintenanceRecord> maintenanceHistory;

    /** For JSON serialization/deserialization */
    public Vehicle() {

    }

    public Vehicle(UUID userId, String VIN, String make, String model, int year, String licensePlate, int mileage) {
        this.id = UUID.randomUUID();
        this.userId = userId;
        this.VIN = VIN;
        this.make = make;
        this.model = model;
        this.year = year;
        this.licensePlate = licensePlate;
        this.mileage = mileage;
        this.maintenanceHistory = new ArrayList<>();
    }

    public Vehicle(UUID userId, String VIN, String make, String model, int year, String licensePlate, int mileage, List<MaintenanceRecord> maintenanceHistory) {
        this.id = UUID.randomUUID();
        this.userId = userId;
        this.VIN = VIN;
        this.make = make;
        this.model = model;
        this.year = year;
        this.licensePlate = licensePlate;
        this.mileage = mileage;
        this.maintenanceHistory = maintenanceHistory;
    }

    /**
     *  Adds a maintenance record to the vehicle, will update vehicle mileage if new 
     * @param record Maintenance record to be added to vehicle
    */
    public void addMaintenance(MaintenanceRecord record) {
        maintenanceHistory.add(record);
        if (record.getMileage() > mileage) {
            mileage = record.getMileage();
        }
    }


    /*(Getters, setters, equals, and hashcodes omitted for brevity)*/
}
```
`Vehicle` is a pretty straightforward class. For the most part it just holds the vehicle data with a little bit of logic to handle updating the maintenance history. Since it is mostly a modeling object for the backend to handle persistent storage the logic will be kept fairly simple. In later steps I added a VehicleDTO that omits backend-specific items such as the `userId` field since that is related to authentication/authorization and will be handled via a separate security configuration.

``` java
package io.thedonutdan.vehiclemaintenance.model;

import java.time.LocalDate;
import java.time.Period;
import java.util.Objects;

/**
 * Represents a record of a specific maintenance performed on a vehicle
 */
public class MaintenanceRecord {
    private LocalDate date;
    private ServiceType serviceType;
    private int mileage;
    private Integer expiryMileage;
    private LocalDate expiryDate;
    private String notes;

    /** For JSON serialization/deserialization */
    public MaintenanceRecord() {

    }
    /** Full Constructor
     * @param date The date the maintenance took place
     * @param serviceType The type of service performed
     * @param mileage The mileage of the vehicle at time of maintenance
     * @param expiryMiles The number of miles after the maintenance at which it should be repeated 
     * (e.g. 5000 means the maintenance is valid for 5000 miles). Can be null to indicate the record
     * should use the default values provided in ServiceType, which can also be null to indicate
     * no explicit expiry milage.
     * @param expiryTime The amount of time after the maintenance at which it should be repeated
     * (e.g. 6 months, 1 year, etc). Can be null to indicate the record should use the
     * default values provided in ServiceType, which can also be null to indicate no explicit
     * expiry time.
     * @param notes Any notes associate with the maintenance.
     */
    public MaintenanceRecord(LocalDate date, ServiceType serviceType, int mileage, Integer expiryMiles, Period expiryTime, String notes) {
        this.date = date;
        this.serviceType = serviceType;
        this.mileage = mileage;
        this.notes = notes;
        if (expiryMiles == null) {
            if (serviceType.getDefaultExpiryMiles() != null) {
                this.expiryMileage = mileage + serviceType.getDefaultExpiryMiles();
            }
        } else {
            this.expiryMileage = mileage + expiryMiles;
        }
        if (expiryTime == null) {
            if (serviceType.getDefaultExpiryTime() != null) {
                this.expiryDate = date.plus(serviceType.getDefaultExpiryTime());
            }
        } else {
            this.expiryDate = date.plus(expiryTime);
        }
    }

    public void computeAndSetExpiryMileage(Integer expiryMiles) {
        this.expiryMileage = mileage + expiryMiles;
    }
    
    public void computeAndSetExpiryDate(Period expiryTime) {
        this.expiryDate = this.date.plus(expiryTime);
    }

    /*(Getters, setters, equals, and hashcodes omitted for brevity)*/
}
```
`MaintenanceRecord` is another pretty simple class, however it has a unique element in that if `expiryMileage` or `expiryDate` are left null in the constructor, they will try to inherit from the `ServiceType` defaults. If those are null, then the service is treated as if it has no expiration (think an alternator replacement, there is no specific maintenance interval for that kind of work).

```java
package io.thedonutdan.vehiclemaintenance.model;

import java.time.Period;
import java.util.Objects;

/**
 * Represents a Service Type with optional default expiry miles and time
 */
public class ServiceType {
    private String name;
    private Integer defaultExpiryMiles;
    private Period defaultExpiryTime;

    /** Default constructor for JSON serialization/deserialization */
    public ServiceType() {

    }

    /** Full Constructor
     * 
     * @param name Name of service type (i.e. 'Oil Change', 'Tire Rotation', etc.)
     * @param defaultExpiryMiles The default amount of miles after which this service should be repeated.
     *  Can be left null to indicate no explicit expiry miles.
     * @param defaultExpiryTime The default amount of time after which this service should be repeated.
     *  Can be left null to indicate no explicit expiry time.
     */
    public ServiceType(String name, Integer defaultExpiryMiles, Period defaultExpiryTime) {
        this.name = name;
        this.defaultExpiryMiles = defaultExpiryMiles;
        this.defaultExpiryTime = defaultExpiryTime;
    }

    /*(Getters, setters, equals, and hashcodes omitted for brevity)*/
}
```
`ServiceType` is really a purely data-focused class. It simply exists to allow configuration of service types based on user preferences, which will be handled on the front end.

### Data Management

We are now moving into the logical side of our backend, where we will handle the actual CRUD operations that will be performed on our vehicles. Originally I had a `VehicleManager` class that handled all the CRUD operations and stored data locally in a JSON. This is perfectly acceptable for a small local app but to align better with common backend design principles I decided to abstract out data storage and make `VehicleManager` a stateless component. To do this I defined a `VehicleDAO` interface as well as a `SQLiteVehicleDAO` implementation to go along with it. This way `VehicleManager` can simply call interface methods on whatever DAO (Data Access Object) implementation is provided, handle authorization (remember the `userId` field from `Vehicle?) and handle transferring data across layers between the actual endpoint controller and the database.

```java
package io.thedonutdan.vehiclemaintenance.DAO;

import io.thedonutdan.vehiclemaintenance.model.Vehicle;

import java.util.List;
import java.util.UUID;

/**
 * Vehicle data access interface for interacting with vehicles in database
 */
public interface VehicleDAO {    
    /** Adds a vehicle to the database
     * @param vehicle Vehicle to be added to the database
     * @return True if insertion is successful, false on failure
     */
    public boolean insert(Vehicle vehicle);
    /**
     * Retrieves a vehicle by its id
     * @param id id of vehicle to retrieve
     * @return vehicle corresponding to id or null if not found
     */
    public Vehicle findById(UUID id);
    /**
     * Retrieves all vehicles related to a specific user id
     * @param id User id to find associated vehicles
     * @return List of vehicles associated with given user id
     */
    public List<Vehicle> findByUserId(UUID id);
    /**
     * Updates a vehicle in the database
     * @param vehicle Updated vehicle
     * @return True on successful update, false on failure
     */
    public boolean update(Vehicle vehicle);
    /**
     * Removes a vehicle from the database
     * @param id Id of vehicle to remove
     * @return True on successful removal, false on failure
     */
    public boolean delete(UUID id);
}
```
And one possible implementation:
``` java
package io.thedonutdan.vehiclemaintenance.DAO.impl;

import io.thedonutdan.vehiclemaintenance.DAO.VehicleDAO;
import io.thedonutdan.vehiclemaintenance.model.MaintenanceRecord;
import io.thedonutdan.vehiclemaintenance.model.ServiceType;
import io.thedonutdan.vehiclemaintenance.model.Vehicle;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.time.Period;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * Vehicle Data Access Object for SQLite configuration
 */
public class SQLiteVehicleDAO implements VehicleDAO {
    private final Connection conn;

    public SQLiteVehicleDAO(Connection conn) {
        this.conn = conn;
    }

    @Override
    public boolean insert(Vehicle vehicle) {
        String vehiclesQuery = """
            INSERT INTO vehicles (
                id,
                user_id,
                vin,
                make,
                model,
                year,
                license_plate,
                mileage
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """;
        
        String maintenanceRecordsQuery = """
                INSERT INTO maintenance_records (
                vehicle_id,
                date,
                service_type_name,
                service_type_default_expiry_miles,
                service_type_default_expiry_time,
                mileage,
                expiry_mileage,
                expiry_date,
                notes
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """;
        
        try {
            conn.setAutoCommit(false);
    
            try (PreparedStatement stmt = conn.prepareStatement(vehiclesQuery)) {
                stmt.setString(1, vehicle.getId().toString());
                stmt.setString(2, vehicle.getUserId().toString());
                stmt.setString(3, vehicle.getVIN());
                stmt.setString(4, vehicle.getMake());
                stmt.setString(5, vehicle.getModel());
                stmt.setInt(6, vehicle.getYear());
                stmt.setString(7, vehicle.getLicensePlate());
                stmt.setInt(8, vehicle.getMileage());
                
                executeStrictUpdate(stmt, 1);
            }
    
            for (MaintenanceRecord record : vehicle.getMaintenanceHistory()) {
                try (PreparedStatement stmt = conn.prepareStatement(maintenanceRecordsQuery)) {
                    ServiceType st = record.getServiceType();
                    stmt.setString(1, vehicle.getId().toString());
                    stmt.setString(2, record.getDate().toString());
                    stmt.setString(3, st.getName());
                    if (st.getDefaultExpiryMiles() != null) {
                        stmt.setInt(4, st.getDefaultExpiryMiles());
                    } else {
                        stmt.setNull(4, java.sql.Types.INTEGER);
                    }
                    stmt.setString(5, st.getDefaultExpiryTime() != null ? st.getDefaultExpiryTime().toString() : null);
                    stmt.setInt(6, record.getMileage());
                    if (record.getExpiryMileage() != null) {
                        stmt.setInt(7, record.getExpiryMileage());
                    } else {
                        stmt.setNull(7, java.sql.Types.INTEGER);
                    }
                    stmt.setString(8, record.getExpiryDate() != null ? record.getExpiryDate().toString() : null);
                    stmt.setString(9, record.getNotes());
                    
                    executeStrictUpdate(stmt, 1);
                }
            }
    
            conn.commit();
            return true;
    
        } catch (SQLException e) {
            try {
                conn.rollback();
            } catch (SQLException rollbackEx) {
                rollbackEx.printStackTrace();
            }
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public Vehicle findById(UUID id) {
        String query = """
                SELECT * FROM vehicles WHERE id = ?
                """;

        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setString(1, id.toString());

            ResultSet rs = stmt.executeQuery();

            if (rs.next()) {
                Vehicle vehicle = new Vehicle();
                vehicle.setId(UUID.fromString(rs.getString("id")));
                vehicle.setUserId(UUID.fromString(rs.getString("user_id")));
                vehicle.setVIN(rs.getString("vin"));
                vehicle.setMake(rs.getString("make"));
                vehicle.setModel(rs.getString("model"));
                vehicle.setYear(rs.getInt("year"));
                vehicle.setLicensePlate(rs.getString("license_plate"));
                vehicle.setMileage(rs.getInt("mileage"));
                vehicle.setMaintenanceHistory(getMaintenanceRecords(id));

                return vehicle;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public List<Vehicle> findByUserId(UUID userId) {
        String vehiclesQuery = """
                SELECT * FROM vehicles WHERE user_id = ?
                """;
        List<Vehicle> vehicles = new ArrayList<>();

        try (PreparedStatement stmt = conn.prepareStatement(vehiclesQuery)) {
            stmt.setString(1, userId.toString());

            ResultSet rs = stmt.executeQuery();

            while(rs.next()) {
                Vehicle vehicle = new Vehicle();
                vehicle.setId(UUID.fromString(rs.getString("id")));
                vehicle.setUserId(UUID.fromString(rs.getString("user_id")));
                vehicle.setVIN(rs.getString("vin"));
                vehicle.setMake(rs.getString("make"));
                vehicle.setModel(rs.getString("model"));
                vehicle.setYear(rs.getInt("year"));
                vehicle.setLicensePlate(rs.getString("license_plate"));
                vehicle.setMileage(rs.getInt("mileage"));
                vehicle.setMaintenanceHistory(getMaintenanceRecords(vehicle.getId()));

                vehicles.add(vehicle);
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }

        return vehicles;
    }

    @Override
    public boolean update(Vehicle vehicle) {
        String deleteVehiclesQuery = """
            DELETE FROM vehicles WHERE id = ?
            """;
        String deleteMaintenanceRecordsQuery = """
            DELETE FROM maintenance_records WHERE vehicle_id = ?
            """;

        try {
            conn.setAutoCommit(false);

            try (PreparedStatement stmt = conn.prepareStatement(deleteMaintenanceRecordsQuery)) {
                stmt.setString(1, vehicle.getId().toString());
                stmt.executeUpdate();
            }

            try (PreparedStatement stmt = conn.prepareStatement(deleteVehiclesQuery)) {
                stmt.setString(1, vehicle.getId().toString());

                executeStrictUpdate(stmt, 1);
            }

            boolean insertSuccess = insert(vehicle);
            if (!insertSuccess) {
                throw new SQLException("Error re-inserting vehicle");
            }

            conn.commit();
            return true;
        } catch (SQLException e) {
            try {
                conn.rollback();
            } catch (SQLException rollBackEx) {
                rollBackEx.printStackTrace();
            }
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public boolean delete(UUID id) {
        String vehiclesQuery = """
                DELETE FROM vehicles WHERE id = ?
                """;
        String maintenanceRecordsQuery = """
                DELETE FROM maintenance_records WHERE vehicle_id = ?
                """;
        try {
            conn.setAutoCommit(false);

            try (PreparedStatement stmt = conn.prepareStatement(maintenanceRecordsQuery)) {
                stmt.setString(1, id.toString());

                stmt.executeUpdate();

            }

            try (PreparedStatement stmt = conn.prepareStatement(vehiclesQuery)) {
                stmt.setString(1, id.toString());
    
                stmt.executeUpdate();
            }

            conn.commit();
            return true;
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return false;
    }

    private void executeStrictUpdate(PreparedStatement stmt, int expectedRows) throws SQLException {
        int affected = stmt.executeUpdate();
        if (affected != expectedRows) {
            throw new SQLException(String.format("Expected %d rows affected, got %d", expectedRows, affected));
        }
    }

    private List<MaintenanceRecord> getMaintenanceRecords(UUID id) {
        List<MaintenanceRecord> records = new ArrayList<>();
        String query = """
                SELECT * FROM maintenance_records WHERE vehicle_id = ?
                """;
        
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setString(1, id.toString());

            ResultSet rs = stmt.executeQuery();

            while (rs.next()) {
                MaintenanceRecord record = new MaintenanceRecord();
                ServiceType st = new ServiceType();
                st.setName(rs.getString("service_type_name"));
                st.setDefaultExpiryMiles(getNullableInt(rs, "service_type_default_expiry_miles"));
                st.setDefaultExpiryTime(getNullablePeriod(rs, "service_type_default_expiry_time"));

                record.setDate(LocalDate.parse(rs.getString("date")));
                record.setServiceType(st);
                record.setMileage(rs.getInt("mileage"));
                record.setExpiryMileage(getNullableInt(rs, "expiry_mileage"));
                record.setExpiryDate(getNullableDate(rs, "expiry_date"));
                record.setNotes(rs.getString("notes"));

                records.add(record);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return records;
    }

    private Integer getNullableInt(ResultSet rs, String column) throws SQLException {
        int val = rs.getInt(column);
        return rs.wasNull() ? null : val;
    }

    private Period getNullablePeriod(ResultSet rs, String column) throws SQLException {
        String raw = rs.getString(column);
        return (raw != null) ? Period.parse(raw) : null;
    }

    private LocalDate getNullableDate(ResultSet rs, String column) throws SQLException {
        String raw = rs.getString(column);
        return (raw != null) ? LocalDate.parse(raw) : null;
    }
}
```
> Oops, forgot to comment this one. Good thing I wrote this blog post and noticed!
{:.note}
CSE 132A Database System Principles finally paid off! Now the queries here are pretty simple, but I did make sure to concern myself with atomic updates to avoid problems like partial vehicle creation/deletion, especially when storing vehicles and associated maintenance records in different tables could lead to orphaned records that would be difficult to catch. Originally I had actually implemented authorization through filtering in my SQL DAO with queries like "SELECT * FROM vehicles WHERE id = ? AND user_id = ?", but later decided that was a bad idea for a few reasons. Number one, it conflicts with my focus on separation of concerns. A DAO should be a DAO. It exists as a way to abstract storage methods, not a way to secretly authorize access. Number two, putting authorization in the implementation without strictly enforcing it in the interface leads to cases where one DAO provides authorization and another does not. This is a dangerous situation to be in. So with that in mind, I decided to go ahead and update my `VehicleManager` to enforce authorization before returning data fetched from the DAO.

``` java
package io.thedonutdan.vehiclemaintenance.manager;

import io.thedonutdan.vehiclemaintenance.DAO.VehicleDAO;
import io.thedonutdan.vehiclemaintenance.model.MaintenanceRecord;
import io.thedonutdan.vehiclemaintenance.model.Vehicle;

import java.util.List;
import java.util.UUID;

/**
 * Manages validated requests from control and provides authorization for database access. Creates, reads, updates, and deletes vehicles.
 */
public class VehicleManager {
    private final VehicleDAO vehicleDAO;

    public VehicleManager(VehicleDAO vehicleDAO) {
        this.vehicleDAO = vehicleDAO;
    }

    /**
     * Adds a vehicle to the database
     * @param vehicle Vehicle to be added to database
     */
    public void addVehicle(Vehicle vehicle) {
        vehicleDAO.insert(vehicle);
    }

    /**
     * Retrieves a vehicle from the database
     * @param vehicleId id of vehicle to be retrieved
     * @param userId id of associated user, must be validated
     * @return Vehicle object if it exists and user is authorized, null otherwise
     */
    public Vehicle getVehicleById(UUID vehicleId, UUID userId) {
        Vehicle v = vehicleDAO.findById(vehicleId);
        if (!v.getUserId().equals(userId)) {
            return null;
        }
        return v;
    }

    /**
     * Retrieves all vehicle associated with given user id
     * @param userId User id to retrieve vehicles for
     * @return List of vehicles associated with given user id
     */
    public List<Vehicle> getVehiclesByUserId(UUID userId) {
        return vehicleDAO.findByUserId(userId);
    }

    /**
     * Updates a vehicle in the database
     * @param userId User id associated with vehicle
     * @param vehicle Updated vehicle object
     * @return True if update is successful, null if update is unsuccessful or user is not authorized
     */
    public boolean updateVehicle(UUID userId, Vehicle vehicle) {
        Vehicle existing = vehicleDAO.findById(vehicle.getId());
        if (existing == null || !existing.getUserId().equals(userId)) {
            return false;
        }
        vehicle.setUserId(userId);
        return vehicleDAO.update(vehicle);
    }

    /**
     * Removes a vehicle from the database
     * @param userId Associated user id used for authorization
     * @param vehicleId Id of vehicle to be removed
     * @return True on successful removal, false on failure or if user is not authorized
     */
    public boolean deleteVehicle(UUID userId, UUID vehicleId) {
        Vehicle existing = vehicleDAO.findById(vehicleId);
        if (existing == null || !existing.getUserId().equals(userId)) {
            return false;
        }

        return vehicleDAO.delete(vehicleId);
    }

    /**
     * Adds a maintenance record to a vehicle in the database
     * @param userId Associated user id for authorization
     * @param vehicleId Id of vehicle to add maintenance record to
     * @param record Record object to be added to vehicle
     * @return True upon successful update, false on failure or if user is not authorized
     */
    public boolean addMaintenanceRecord(UUID userId, UUID vehicleId, MaintenanceRecord record) {
        Vehicle vehicle = vehicleDAO.findById(vehicleId);
        if (vehicle == null || !vehicle.getUserId().equals(userId)) {
            return false;
        }

        vehicle.addMaintenance(record);
        return vehicleDAO.update(vehicle);
    }
}
```
And we have properly separated authorization from data access. Now in this iteration, and currently, it could be noticed that there is no authorization checks on vehicle creation. Why is this? Well because in the layer above I actually convert a `VehicleDTO` (which doesn't carry the `userId` field) to a `Vehicle`. The controller injects the associated `userId` automatically into the vehicle passed to the manager so it's really not much of a concern. However, upon rethinking this code as I upload it into the blogpost I realize this is probably not great practice. Even though our current implementation guarentees authorization, future refactors could silently break this guarantee. This goes against the concept of TDD (Test-Driven Development) which I've been adhering to so far. So I plan on my next commit introducing some logic like:
``` java
    /**
     * Adds a vehicle to the database
     * @param vehicle Vehicle to be added to database
     * @param userId Associated user Id for authorization
     */
    public boolean addVehicle(Vehicle vehicle, UUID userId) {
        if (!userId.equals(vehicle.getUserId())) {
          return false;
        } else {
          return vehicleDAO.insert(vehicle);
        }
    }
```
This will properly handle the case where some future implementation of other components could theoretically try to create a vehicle with a user id stored in the vehicle that does not match the authenticated id. This helps to separate concerns and avoid unwritten guarantees that could cause regressions in later updates.

## Conclusion

That takes care of modeling, persistence storage, and stateless management. Note the lack of data validation in `VehicleManager`. This is a deliberate design choice. I decided to put data validation in the controller which will provide endpoints. This is a branching point where I think either packaging validation and authorization into the controller that exposes the endpoints would be reasonable enough and slightly reduce complexity, but I felt that it followed my mantra with this project to separate these two aspects into different responsibilities. What are the benefits of doing it this way? Separation of concerns, testability, and easier identification of failure points. The cons? More complex code/file structure, and `VehicleManager` will now always assume it is being passed validated data. So changes on layers above it will have to keep that in mind.

## Testing

I mentioned utilizing TDD earlier but have not provided any tests in this post. Considering the lengthiness of some of the codeblocks I omitted the actual tests but they can easily be viewed [here](https://github.com/thedonutdan/VehicleMaintenanceReactApp/tree/main/backend/src/test/java/io/thedonutdan/vehiclemaintenance). Due to the fairly simple nature of our data model/management the tests are quite straightforward. After implementing the server, api, and security side of things I will have to work on also implementing some integration testing to go along with the existing unit tests.

## Next Steps

The next steps for this project will be setting up a server, exposing API endpoints, and getting a small frontend going to ensure it is working. Further on we'll actually implement authentication properly and then move on to rigging up a complete frontend.

Sourcecode: [github.com/thedonutdan/VehicleMaintenanceReactApp](https://github.com/thedonutdan/VehicleMaintenanceReactApp)